# Clojurescript Kernel of Pinkgorilla Notebook

We use self-hosted clojurescript via klipse library.
Klipse is well maintained and production proof.
It allows to include custom dependencies.

Our fork is in https://github.com/pink-gorilla/kernel-cljs

Great Reagent demo using klipse is here: https://blog.klipse.tech/clojure/2019/02/17/reframe-tutorial.html
https://day8.github.io/re-playground/?gist-id=saskali/d9b7d0ccc36cdb89ef49a56a531e5b25# also done with klipse plugin


Klipse automatically generates via clojure macros cache files of dependencies that can be used
at runtime. 

# Dynamically add klipse dependencies 

This still needs to be implemented:

https://github.com/viebel/codox-klipse-theme

Lets' say your github user is my_user and your repo is my_repo, with namespace my_repo.my_ns with a function my_func, then add the following options to :codox:
:codox {:metadata {:doc/format :markdown}
:output-path "docs"
:themes [:default [:klipse
{:klipse/external-libs
"https://raw.githubusercontent.com/my_user/my_repo/master/src/"
:klipse/require-statement
"(ns my.test
(:require [my_repo.my_ns :as my_ns :refer [my_func]]))"}]]
}

data-static-fns: (default false) set to true for using static dispatch
    http://blog.klipse.tech/clojurescript/2016/04/13/static-fns.html
    
data-external-libs: comma separated list of github repositories to resolve dependencies: you need to provide the full list of dependencies (including the dependencies of dependencies recursively). See for instance Lambda Caclulus with clojure and Klipse
data-print-length: (default 1000) max number of items in collections to display - useful to prevent browser stuck when evaluating infinite sequences like (range)

You can require clojure libraries in your code snippet but the code might take a while to execute, as the code of the library is JIT loaded from github. Here is an example with clojure.set:

When you require a clojure library, klipse will try to load the library from several repos. As a consequence, if you open the browser dev tools, youâ€™ll see a lot of 404s.


# Ways to include clojurescript code

compiled with :advanced
- functions to be used in repl need to be exported with :export. 

compiled with :simple
- that all of the function entry points remain available.

self-hosted ClojureScript and compile new code in the browser. 
- Using self-hosted ClojureScript results in more code being shipped to the browser, but it results in the most dynamic / flexible environment.

Dmitri Sotnikov was looking into dynamically adding new functionality to a web app written with ClojureScript and I had chatted with him briefly about marking cljs.core functions with :export in order to try to have your cake and eat it too with respect to :advanced and dynamically loaded code. It might be worth checking with him to see if they explored that approach.
https://yogthos.net/posts/2016-05-20-ExpandableWidgetsInReagent.html



# Other options for self hosted clojurescript

- https://clojurescript.org/guides/code-splitting

- Shadow CLJS
  https://code.thheller.com/blog/shadow-cljs/2019/03/03/code-splitting-clojurescript.html
  It might be that lazy components are the way to implement a requirejs for reagent components. Different use case but perhaps similar implementation.
  https://clojureverse.org/t/shadow-lazy-convenience-wrapper-for-shadow-loader-cljs-loader/3841


- https://github.com/arichiardi/replumb
  Library for self hosted clojurescript.
  Lots of goodness, but seems no longer maintained.
- https://github.com/joakin/cljs-browser-repl/tree/master/src/cljs_browser_repl/net
- https://github.com/ctford/klangmeister 
  A simple way to include limited amount of code


- https://github.com/bendyworks/conwip-modules
  Conwip Modules - automatic loading of clojurescript modules.


- sends cache files via http:
https://github.com/viebel/klipse/tree/master/docs/cache-cljs
https://viebel.github.io/cljs-analysis-cache/cache//klipse_clj_SLASH_macros$macros.js
https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js?v=8.0.1

- generate cache files: 
  via lumo: https://github.com/viebel/klipse/blob/64df984d1c41cd2cdfa36d2d36d36f29793fdf15/scripts/generate-clojure-spec-cache.cljs
  https://github.com/viebel/klipse/blob/master/scripts/cache/build.clj

- https://stackoverflow.com/questions/51573858/how-can-i-run-eval-in-clojurescript-with-access-to-the-namespace-that-is-calling

- planck is the most advanced: It can do js dependencies that follow clojurescript naming convention =>
this means it can require UNKNOWN dependencies that have been generated by clojurescript.
https://github.com/planck-repl/planck/blob/master/planck-cljs/src/planck/js_deps.cljs

- saite self hosted cljs: https://github.com/jsa-aerial/saite/blob/3f90adc2e40cf4265b3088dd0f24909028380cdd/src/cljs/aerial/saite/compiler.cljs


- mfikes 
https://gist.github.com/mfikes/e00202b2de7cc2352fedcf92b1fe60dc





https://github.com/pink-gorilla/cljs-eval-example/blob/master/project.clj



